---
title: 	TokenPay Documentation

language_tabs:
- cpp
- shell
- json


toc_footers:
- <a href='https://www.tokenpay.com/'>TokenPay Website</a>
- <a href='https://medium.com/tokenpay'>Blog</a>
- <a href='https://github.com/tokenpay'>Github</a>
- <a href='https://bitcointalk.org/index.php?topic=2400499.0'>Bitcoin Talks</a>

search: true
---

# About TokenPay
TokenPay is a blockchain project that incorporates Bitcoin cryptographic
technology with advanced security and privacy features. Additionally,
TokenPay is building out a platform that combines banking and a closed-end
private exchange. This enables wider adoption of the coin via consumer and
merchant services. Developing a TokenPay coin and the infrastructure to
support its everyday seamless use is a crucial step.
## History
### Bitcoin

Due to their superiority over traditional methods of exchange, virtual currencies are quickly becoming very popular. Prior to Bitcoin, the largest problem for these virtual currencies was the prevention of double spending attacks. In short, a double spend attack is the malicious act of executing multiple transactions using the same units of currency (the equivalent of counterfeiting paper money). Bitcoin was able to solve this major issue by integrating a public ledger of all previous transactions known as a block chain.


Bitcoin relies on a peer-to-peer network (P2P) where each member (peer) of the network has the ability to analyze every transaction ever executed. This method of checks-and-balances allows peers to see if coins have been previously spent before accepting any new transactions, thus limiting double spend attacks.


The public nature of a block chain allows anyone to observe the entire transaction history and holdings of every participant. Unfortunately, while names and personal data aren't revealed in transaction records, a block chain such as Bitcoin’s does not allow for native anonymity or privacy. Addresses can be linked and traced to individuals and businesses by block chain anaylsis.


### TokenPay


## Mission Statement

In 2010 I was introduced to a group working on a startup called TokenPay.
Following a presentation by the company, I signed on as an investor. The
mission was clear. TokenPay wanted to provide a secure and anonymous way
for a consumer to pay a merchant by credit card. The technology was
impressive and unique. Transactions occurred directly on the merchant’s
website through a client-side API. The platform worked, but there was a key
missing element. That is, the ability to obtain card processing proved to be an
insurmountable hurdle for the team. Despite an active compliance program
that included all the usual KYC and AML procedures, no bank would agree to
process for TokenPay. Ultimately the business failed because of this. But there
was no shortage of demand with wannabe consumer and merchant clients
clamoring for an account. The public was clearly beginning to embrace the
idea of digital cash. It was however too early.
Fast forward to 2013 and a new emerging payment technology called Bitcoin
was in the news after spiking in value from virtual pennies to over $1000.
Despite my suggestion for a potential move to a blockchain payment platform,
it was simply too late for TokenPay to pivot. The core team had already thrown
in the towel having been handily defeated by the iron curtain of the banking
industry. At this point I began to deeply study fintech and this new form of
money known as cryptocurrencies. I started compulsively writing for various
financial media such as TheStreet and Seeking Alpha. It was at the latter site
where I met a fellow writer and former hedge fund analyst named Derek Capo.
Our relationship blossomed due to a mutual obsession over a Park City
headphone company called Skullcandy. Eventually we became real life friends
and business partners. We created a startup of our own called eFin. This is a
website where ordinary investors could receive hedge fund level research in an
automated fashion.
Around the same time, I stumbled upon an online stock trading community
called investFeed. The nascent social media startup happened to be in the
midst of its seed round. After speaking at length with the operators, I decided
to make an investment. Outside of the two founders, I remain the largest
shareholder of this company. During this time, Derek and I managed to build
an impressive financial research platform. Through this process we met Tony
Weeresinghe. He is a former executive of the London Stock Exchange and the
founder of Ustocktrade. Tony was impressed with the type of research that
eFin was producing and he invited us to present at the MIT Fintech
Conference early in 2016. While at the conference, eFin launched an official
partnership with Ustocktrade. The AI driven stock scoring system we
developed was fully integrated into the Ustocktrade platform. This was great
and all for us and it sure seemed like eFin was off to the races. However, I
noticed something very different. The fintech conference was being
dominated not by stock discussion, but by blockchain.
© 2017, TokenPay.com or its aliates | TPAY is a utility token used in the TokenPay platform. Purchase does not constitute investment. 12
Early in 2017 after realizing the challenge that investFeed was facing in terms
of traffic generation, I suggested to the founders that they should immediately
focus on cryptocurrencies rather than stocks. While there were other investors
that remained naturally apprehensive of the abrupt change in strategy,
investFeed embraced the new concept. The blueprint was written and an ICO
was quickly launched.
investFeed sold approximately $4 million of an Ethereum based token in a
matter of weeks. The investFeed platform is now flourishing. Traffic is surging
and the future looks extremely bright. I could not be happier for the team and
how my early seed investment has begun to sprout. With a roadmap that
includes grandiose but realistic plans all the way out till the end of next year,
I’m excited to see this all play out. The shift to cryptocurrencies was timely and
no doubt the right move. We have not even seen the tip of the iceberg yet
when it comes to blockchain technology, particularly when it comes to
cryptocurrency applications. And I know this, because at the same time Derek
was working hard on something very special. I had to get in on it.
After constantly hearing about countless hacks causing chaotic volatility in the
cryptocurrency markets, Derek came up with a novel idea. He partnered with a
group of obsessively privacy driven cryptographic coders on a top secret
project. Over the course of nearly a year of intense programming the
blockchain team created a new secure coin technology that can only be
described as Bitcoin on steroids. With encryption and anonymity dominating
the headlines, this appeared to be a winning concept. But to be a game
changer, it was clear that what is needed is more than just a coin. Simply put,
the missing link in all of these crypto platforms is the ability to turn digital
assets into cold hard cash that can be realistically spent in whatever quantity
without hassle. Through my international financial contacts I managed to
locate the ideal bank for sale. We moved quickly to sign the necessary
paperwork to begin the intense due diligence procedure. Firm plans are in
place for the buildout of a next generation blockchain banking and payments
platform driven by an amazing team of top industry professionals and
advisors. This has been a long road for everybody involved in the TokenPay
project since inception. However, I finally feel that all the pieces are now firmly
in place. As Freud so eloquently said, “One day, in retrospect, the years of
struggle will strike you as the most beautiful.”

## Other cryptocurrency projects
### Network architecture

<span class="tokenpay-table"></span>

|                      |   TOKENPAY   |   MONERO   |    DASH    |  ZCASH  |  BITCOIN  |  
| -------------------- | ---------- | -----------| ---------- | ---------- | ---------- | 
| **Proof-of-Work**    |    false    |    true    |    true    |    true    |    true    |
| **Proof-of-Stake**   |    true    |    false    |    false    |    false    |    false    | 
| **Bitcoin Based**    |    true    |    false    |    true    |    true    |    true    |   
| **CryptoNote Based** |    false    |    true    |    false    |    false    |    false    |   

### Anonymity features

<span class="tokenpay-table"></span>

|                      |   TOKENPAY   |   MONERO   |    DASH    |    BITCOIN  |  ZCASH  |
| -------------------- | ---------- | -----------| ---------- | ---------- | ---------- |
| **Mixing**    |    false    |    false    |    true    |    false    |    false    |
| **Stealth Addresses**   |    true    |    true    |    false    |   false    |    true    |
| **Ring Signatures**   |    true    |    true    |    false    |    false    |    true    |
| **Zero Knowledge Proofs**   |    true    |    true    |    false    |    false    |    true    |
| **Untraceable**    |    true    |    true    |    undefined    |    false    |    undefined    |
| **Unlinkable**    |    true    |    true    |    false    |    false    |    undefined    |
| **End to end Anon** |    true    |    true    |    false    |    false    |    undefined    |

### Wallet features

<span class="tokenpay-table"></span>

|                      |   TOKENPAY   |   MONERO   |    DASH    |    BITCOIN    |  ZCASH  |
| -------------------- | ---------- | -----------| ---------- | ---------- | ---------- | 
| **GUI Wallet**    |    true    |    false    |    true    |    true    |    progress    |
| **HTML Interface**   |    true    |    false    |    false    |    false    |    false    |
| **Lite Wallet**    |    true    |    false    |    false    |    false    |    false    |
| **HD Wallet**    |    true    |    false    |    false    |    true    |    undefined    |
| **Multisignatures** |    progress    |    false    |    false    |    true    |    undefined    |

- GUI: General User Interface
- HD: Hierarchical Deterministic

### Other Features

<span class="tokenpay-table"></span>

|                      |   TOKENPAY   |   MONERO   |    DASH    |  BITCOIN  |  ZCASH  |
| -------------------- | ---------- | -----------| ---------- | ---------- | ---------- | 
| **Web Wallet**    |    false    |    true    |    false    |    false    |    false    |
| **Fast Transactions**   |    false    |    false    |    true    |    false    |    false    |
| **Incentive Nodes**   |    false    |    false    |    true    |    false    |    false    |

### Blockchain Decentralized Apps

<span class="tokenpay-table"></span>

|                      |   TOKENPAY   |   MONERO   |    DASH    |  BITCOIN  |  ZCASH  |
| -------------------- | ---------- | -----------| ---------- | ---------- | ---------- | 
| **Encrypted Chat**    |    true    |    false    |    false    |    false    |    false    |
| **MarketPlace**   |    progress    |    false    |    false    |    false    |    false    |

# Community

TokenPay will only have a total of 25 million coins ever produced. This is unlike
a centralized fiat currency system where money supply can be increased by
human decision. TokenPay is fostering a strong user driven community by
allocating 25% of the total coins produced for Proof-of-Stake rewards. The
TPAY rewards are given at a distribution rate of 5% per year. Rewards are
pro-rated and distributed on a daily basis. A typical user with 100 TPAY in a
TokenPay branded wallet will receive 5 coins per year or 0.0137 TPAY per day.

[tokenpay.com](https://www.tokenpay.com) is dedicated to help Tokenpay’s community develop in a sustainable way.

## Social Media

Below you will find a list of places where you can find other TokenPay users, community members and news.


- Blog: [medium.tokenpay.com] (https://medium.com/tokenpay)
- Forum: [bitcointalk.tokenpay.com] (https://bitcointalk.org/index.php?topic=2400499.0)
- Twitter: [twitter.com/tokenpay] (https://twitter.com/tokenpay)
- Telegram: [telegram.tokenpay.com] (https://t.me/joinchat/GgZih0NrYt2F11oXwQ11Cg)
- Reddit: [reddit.com/r/ttokenpay] (https://www.reddit.com/r/tokenpay/)
- Facebook: [facebook.com/tokenpay] (https://www.facebook.com/tokenpay/)

# Currency

## Specification

Specification | Value
--- | ---
Protocol | **PoSv3**
Block Time | **60 seconds**
Difficulty Re-target | **every block**
Nominal Stake Interest | **5% annually for the first year and 1% after**
Min Stake Age | **2 hours** (no max age)
P2P Port | 8800
RPC Port | 8801

### Transactions

| Specification   | Value          |
| --------------- | -------------- |
| Min Fee         | **0.0001 TPAY** |
| Confirmations   | **6**         |
| Maturity        | **100**        |

## Exchanges

Currently you can only buy TokenPay (TPAY) once you have Bitcoin (BTC). Bitcoin can be bought at a number of places [link needed](). Once you have BTC you can buy TPAY on a number of crypto-to-crypto currency exchanges.

TokenPay is available at the moment on:

- [QRYPYOS] (https://home.qryptos.com/basic/TPAYBTC)
- [QRYPYOS] (https://home.qryptos.com/basic/TPAYETH)
- [QRYPYOS] (https://home.qryptos.com/basic/TPAYQASH)




## Network Consensus




TPAY Circulation |  15,295,909 TPAY


### Proof of Stake (PoS) - Ongoing
Specification | Value
--- | ---
Algo | Sha256 (formerly Scrypt)
Nominal Stake Interest | 1% annually

### Multipool
PoW mining has ended, but you can still use your mining rigs to earn ShadowCash by using the [TPAY Multipool](https://www.shadowpool.info/). Point your rigs and enter your TPAY payout address to begin!

# TokenpayCore

## Introduction

TokenpayCore is the main engine on which all decentralized actions take place, it is used when referencing to the back end of the program and takes cares of the network bootstrapping and propogation of data throughout it. It is also in charge of synchronising and verifying the blockchain for each node to make sure it can participate in the network.

The data being propogated are encrypted messages and transactions, you can find more information about the workings of these in other sections of this documentation.

## HTML  (GUI)

TokenPay has a HTML cryptobrowser at the core of its graphical user interface (GUI). One thing you may have noticed is that we strive for the best user experience (UX) and that involves a good graphical interface. We chose to use a combination of HTML and Javascript because this allows web designers and developers to help the project. They are very familiair with creating a good user experience through a simple yet beautiful interface.

![Overview]

![Wallet]

## Hierarchical Deterministic Wallet (HD)

The [Hierarchical Deterministic](https://bitcoin.org/en/glossary/hd-protocol) (HD) key creation and transfer protocol ([BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)), allows users to create [child keys](https://bitcoin.org/en/glossary/child-key) from [parent keys](https://bitcoin.org/en/glossary/parent-key) in a hierarchy.
In essence this means that you only have to back up your wallet once, all private keys are derived from the mnenomic seed (up to 24 words) and they can be retrieved anytime if you have the seed. This means that you'll never have to worry about backups as long as you have one, coins will never be lost.


<aside class="warning">
ALWAYS BACKUP WALLET.DAT FIRST
</aside>

**STEP 1**

1. Save your wallet.dat and rename it.
2. Load the new TokenPay Latest client
3. Create a new HD Wallet (Options --> Key Management --> New Key) - give it a "name".
4. Goto (Key Management --> Advanced Management) and make sure that the new "name" account is showing as "default".
5. The wallet will have pre-generated a Default normal and stealth address
6. Send some funds to test (from your old wallet)

So now I would suggest you try a restore of this account to test it!

**STEP 2**

1. Save your wallet.dat and rename it.
2. Load the TokenPay Latest Client
3. Goto (Options --> Key Management --> Restore) - complete steps
4. Goto (Help --> Debug --> Console) and type scanforalltxns 590000
5. You should see your test transaction show up.


To create a better user experience TokenPay implemented [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki), allowing users to create a HD wallet based on a mnenomic sentence consisting of 24 words and the ability to secure that with a password for plausible deniability.

### Links

- [HD Protocol](https://bitcoin.org/en/developer-guide#term-hd-protocol) — Bitcoin.org Developer Guide
- [BIP32: hierarchical deterministic wallets](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) — Bitcoin Improvement Proposals
- [Deterministic wallet](https://en.bitcoin.it/wiki/Deterministic_Wallet) — Bitcoin Wiki



# Download

## Desktop Wallet
- Latest (https://tokenpay.app.box.com/v/tokenpaywindowswallet)

## MAC Wallet 
- Latest (https://tokenpay.app.box.com/v/TokenPayMACWallet)

## Linux Wallet
-Latest (https://www.tokenpay.com/images/tokenpay-page43.png)

## Android Wallet
-Latest (https://play.google.com/store/apps/details?id=com.tokenpay.wallet&hl=en)





## Useful Paths
```
Windows
```
>%appdata%\TokenPay

```
OSX
```
>~/Library/Application Support/TokenPay/

```
Linux
```
>~/.tokenpay/

<aside class="warning">Warning: deleting the wallet.dat file in this directory will cause you to lose all of your coins if you have no back up.</aside>
These are the paths where your **blockchain data, wallet and pretty much everything related to TokenPay** is stored.

When using the blockchain.zip method these are the location where you extract the blockchain.zip file.

## Bootstrap?

<aside class="notice">Use this method to synchronize your node within 10 minutes!</aside>

When you load the TokenPay Wallet for the first time it connects to the peer-to-peer network and starts to synchronise the block chain. **By default the client will configure a full node.** A full node needs an up-to-date, full copy of the ShadowCash block chain on your computer to properly function.

A full node is very useful for the following reasons:

1. Looking to help further strengthen the network by providing a full peer/node.
2. Already own TokenPay (TPAY) and wish to participate in staking.
3. Plan to run services on the TokenPay network that require a full node.




If you decide that a full node is for you then the full sync of the block chain can take quite a while; sometimes up to 24 hours depending on your hardware. To speed this up the team provides compressed backups of the blockchain in a "bootstrap" file. Adding the current bootstrap to your local directory speeds up the syncronization process which will get your wallet up and running much quicker than the default method.

1. Close the TokenPay Wallet and [download the latest Blockchain file from GitHub](https://github.com/tokenpay)
2. Place the ```blockchain.zip``` file in one of the locations as seen above, depending on your operating system
3. Unzip the ```blockchain.zip``` file
4. Start the TokenPay Wallet again (The client might be unresponsive but don't worry - it's just loading all the blockchain data)


## Source Code

TokenPay its source code is open-source and available at our [GitHub repository](https://github.com/tokenpay)

## Linux Daemon from Source (tokenpayd)
```
Update and Install dependencies:
```
>sudo apt-get update && apt-get upgrade
>sudo apt-get install git build-essential libssl-dev libdb-dev libdb++-dev libboost-all-dev libqrencode-dev

```
Download the source code and compile shadowcoind
```
>git clone https://github.com/tokenpay
>cd tokenpay/src
>make -f makefile.unix
>strip tokenpayd

```
Run the daemon
```
>./tokenpayd -daemon

```
On the inital start-up tokenpayd will return an error because it cannot find the configuration file tokenpay.conf
```
>nano ~/.tokenpay/tokenpay.conf

```
Add the following to your config file, changing the username and password to something secure:
```
>daemon=1
>rpcuser=[secure username]
>rpcpassword=[secure password]

```
You can copy the username and password provided in the earlier error message as the username and password is randomly generated and secure

You can now start the tokenpayd daemon once more
```
>tokenpayd

```
List all commands for tokenpayd
```
>tokenpayd help

```
Update tokenpayd
```
>git pull

```
Stopping tokenpayd
```
>tokenpayd stop


If you wish you can also compile directly from source, follow these instructions to compile latest ShadowCore headless daemon based on Debian/Ubuntu. Please also refer to the build instructions for more detailed information.*

## Graphical Linux Wallet from Source (TokenPay Qt)

```
Update and Install dependencies
```
>sudo apt-get update && apt-get upgrade
>sudo apt-get install git qt5-default qt5-qmake qtbase5-dev-tools qttools5-dev-tools build-essential libboost-dev libboost-system-dev libboost-filesystem-dev libboost-program-options-dev libboost-thread-dev libssl-dev libdb++-dev libminiupnpc-dev libqt5webkit5-dev

```
Download the source code and compile tokenpay QT
```
>git clone https://github.com/tokenpay
>cd tokenpay
>qmake
>make

```
Run the executable found within the shadowcoin folder with :
```
>./tokenpay


* Advanced users only.
If you wish to you can also compile directly from source, follow these instructions to compile latest TokenPay QT GUI Wallet based on Debian/Ubuntu. Please also refer to the build instructions for more detailed information.*

```
Update TokenPay QT
```
>git pull




## TokenPay Tokens (TPAY)


In order to transact anonymously, we have introduced ```an anonymous token```, which we will refer to as TokenPay. TokenPay can be minted, destroying TokenPay (TokenPay) in the process, and outputting a group of TokenPay tokens totalling the same value (minus the transaction fee) of the destroyed TPAY.
TokenPay Tokens take form of outputs on the TokenPay blockchain and each one of them has its own private and public key.

TPAY is only spendable by providing a ```traceable ring signature``` to prove ownership of a token of the same value.

Once a TokenPay Token is created, we can claim a different output in pool of the same value, by providing a traceable ring signature. We provide a keyImage of the private key to prevent double spending.

To increase the pool of outputs available for ring signatures, the TPAY value is broken up into separate TokenPay Tokens for each decimal place of the total value. The tokens are further broken up into values of 1, 3, 4 and 5. For example 1.7 TPAY would become 3 tokens of values 1.0, 0.3 and 0.4.

- For clarity: TokenPay (TPAY) is the native *public* token, TokenPay Tokens - aka TokenPay - is the *private* token.

## Dual-key Stealth Addresses
### Introduction, History and Acknowlegements

Dual-key stealth addresses is one of the cornerstones of most anonymous cryptocurrencies currently available. The usage allows the recipient to remain anonymous, even after sharing his stealth address publicly.

Once the stealth address has been revealed to the payer(s), it will enable the payee to receive infinite unlinkable payments.

**That means that each payment to a Stealth address computes a new unused normal address into which the funds will be received. Any eavesdropper will be unable to link the two addresses.**

The original visionaries were the creators of Bytecoin, for whom we are thankful. Their technical documentation link has been included in the references *[1]*.

- The information they provide may not always apply to TokenPay.
- Bytecoin is built on Cryptonote codebase.

We would also like to thank **Peter Todd**. Peter figured out how to implement stealth addresses into Bitcoin. You can find a link to his white paper in the references *[2]*.
He is a Bitcoin core developer and has done amazing work on Bitcoin and deserves the mention.

Peter is also associated with DarkWallet, whose wiki provided lots of information on the working of stealth addresses. Again, the link can be found in the references *[3]*.

The documentation at *sx* can also be very helpful to understand the concept of stealth addresses. They also provide tools that explain how they work. *[4]*.


### Address Encoding
```cpp
//formatting function of stealth address
std::string CEKAStealthKey::ToStealthAddress() const
{
// - return base58 encoded public stealth address

std::vector<uint8_t> raw;
raw = Params().Base58Prefix(CChainParams::STEALTH_ADDRESS);

raw.push_back(nFlags);
raw.insert(raw.end(), pkScan.begin(), pkScan.end());
raw.push_back(1); // number of spend pubkeys is 1
raw.insert(raw.end(), pkSpend.begin(), pkSpend.end());
raw.push_back(0); // number of signatures
raw.push_back(0); // ?
AppendChecksum(raw);

return EncodeBase58(raw);
}; //extkey.cpp
```

Stealth addresses are generated in a different way than normal bitcoin addresses, but they have a similair structure.
A dual-key stealth address contains a lot more information than a normal Bitcoin address because it requires the sender of a transaction to know the public scan key and the public spend key **which is not stored on the blockchain**.
All data required to perform such transaction is derivable from the stealth address itself.

![available languages](images/cpp.png)

Just like a Bitcoin address, all data below is **Base-58** encoded, which also explains the familiar looking form.


Version | Options | Public Scan Key | # Public Spend Keys | Public Spend Key | # of signatures | Length of prefix | Prefix | Checksum
--- | --- |--- | --- |--- | --- |--- | --- | ---
0x28 | 0  | 33 bytes | 1 | 33 bytes | 0 | 0 | (not used) |  4 bytes

Parameter | value
--- | ---
**Version:**  | The hexadecimal representation (= 0x28) of '40' is used for the current release on the mainnet. The version field to keep track of updates of the protocol.
**Options:** | Field is always set to 0.
**Public scan key:** | This fields holds the public scan key, 33 bytes of data.
**Amount of public spend keys:** | The current protocol uses one public spend key for each Stealth address. The ability to specify multiple spend keys remains in the protocol because it is useful for the implementation of multi-signature addresses.
**Public spend keys:** | This fields holds the public spend key, 33 bytes of data.
**Amount of signatures:** | Field is always set to 0.
**Length of prefix:** | Field is always set to 0.
**Prefix:** | No prefix is used, since length is equal to zero. Other coins do make use of this field, more information can be found [here](https://wiki.unsystem.net/en/index.php/DarkWallet/Stealth#Computing_prefixes)
**Checksum:** | Contains the first 4 bytes of the SHA-256 hash provided by the operation: SHA256(SHA256(previous_data_concatenated)). The same checksum function used in Bitcoin addresses.

### Address Computation and Transaction Format
```

Alice (receiver)
publicSpendKeyAlice = public spend key
privateSpendKeyAlice = private spend key

publicScanKeyAlice = EC point, 33 bytes
privateScanKeyAlice = integer, 32 bytes

This is where it gets a bit more complicated, but no magic, just math!
G = Generator, the primitive root

To continue on, we have to understand how the public addresses are generated.
A public key is the private key multiplied by the primitive root G.

publicSpendKeyAlice = privateSpendKeyAlice * G
publicScanKeyAlice = privateScanKeyAlice * G

Bob (sender)
e = ephem secret key = ephem private key
publicEphemKey = e * G
Knows the public scan key of Alice (publicScanKeyAlice)!

Ephem is short for ephemeral, which means “short lived”. The ephem secret and public key are only used once and change on every stealth transaction.

Bob now publishes the public ephem key (publicEphemKey) to the receiver Alice.

Because of the diffie-hellman algorithm ONLY THE RECEIVER AND SENDER can deduct the shared secret from the public ephem key.

SharedSecret = SHA256(ephem private key  * publicScanKeyAlice) (Formula for Sender)
SharedSecret = SHA256(privateScanKeyAlice * publicEphemKey) (Formula for Receiver)

Bob can now generate the public key to where it should send the coins.
publicKeyToPay = publicSpendKeyAlice + SharedSecret * G

Alice has two different ways of find out the the public key where the coins will go to.
When the wallet is encrypted:
publicKeyToPay = publicSpendKeyAlice + SharedSecret * G

When the wallet is decrypted:
publicKeyToPay = (privateSpendKeyAlice + SharedSecret)* G
```

If Alice would post a normal address publicly, anyone can explore the blockchain and see the transactions that belong to her. Stealth addresses solve this privacy issue. Alice can post her Stealth address publicly, and nobody will be any wiser of what transactions belong to her.

**It's extremely important to note that the payer derives a new NORMAL address from the Stealth address, to which the funds will be sent and in that process only allowing the payee to compute the corresponding private key.**

It uses a clever mathematical principle called the "Diffie-Hellman Key Exchange", which allows two entities to generate a shared secret based on their keypairs. An eavesdropper is unable to compute the shared secret, enabling private communication between the two. In the case an eavesdropper has full control over one of the keypairs (private and public key) then privacy is obviously broken.

It is important to mention that we can not use the ```SharedSecret``` directly to generate the keypair, because that would also allow the sender control over the private key. Instead a bit of mathematical "magic" (BIP32-style derivation) is applied: the ```SharedSecret``` is added to ```PrivateKeyAlice``` and we use that to generate the new keypair.

It uses a system of dual-keys to allow the wallet software to scan for stealth payments (using ```ScanKeyAlice```) but not make any transactions, because that would require decryption of the wallet/stealth key.
All transactions have to be made with the ```SpendKey```, only available after decrypting your wallet.
The dual-key is more of a security practice, it allows a wallet (while encrypted) to scan for transactions. If it weren't implemented, the wallet would have to remain decrypted, rendering the protection provided by the encryption useless.

The payee has to know the ephem public key to compute the ```SharedSecret```, but how is that data transferred from payer to payee? The ephem public key is embedded in the *stealth metadata*.

Any stealth transaction will require at least 2 outputs, the stealth metadata and the actual spendable output.

Each spendable output in a stealth transaction will be preceded by the metadata for that output. Regular spends do not need metadata, because there is no use of ephem keys in normal transactions.

Format goes as following:

Output | Content
--- | ---
out #1 | **metadata for spend A**
out #2 | **stealth spend A**
out #3 | metadata for spend B
out #4 | stealth spend B
out #5 | *regular spend C*
out #6 | metadata for spend D
out #7 | stealth spend D


### References
[1] ByteCoin, *Technical Documentation*, 2015, Available at [https://bytecoin.org/documentation/](https://bytecoin.org/documentation/

[2] Peter Todd, *[Bitcoin-development] Stealth Addresses*, 2014,  Available at  [https://sourceforge.net/p/bitcoin/mailman/message/31813471/](https://sourceforge.net/p/bitcoin/mailman/message/31813471/)

[3] Dark Wallet, *Stealth*, 2015,  Available at [https://wiki.unsystem.net/en/index.php/DarkWallet/Stealth](https://wiki.unsystem.net/en/index.php/DarkWallet/Stealth)

[4] Sx, *Stealth*, 2015,  Available at [https://sx.dyne.org/stealth.html](https://sx.dyne.org/stealth.html)


## Ring signatures
The ring signatures are a crucial part to anonymize the sender of a transaction.

As previously mentioned, all tokens have their own public and private key. It consists of the public key of the token being spent, plus the public keys from 3 to 200 other tokens of the same value as the token being spent. The nature of ring signatures makes it impossible to discover member of the coins in the ring signature is being spent, and transactions are no longer traceable.

[](http://www.texpaste.com/n/xaypn9ni)

<aside class="notice">TO COMPLETE</aside>

### Double Spend Prevention

The ring signature tags (keyImage) of the spent TokenPay tokens are embedded in the transaction to prevent double spends. Each tag is unique to the
token, regardless of the other members of the ring signature.

When a new transaction contains a keyImage that has already been used, and thus is present in the blockchain, the new transaction will be rejected by the network.

## Spending TokenPay Tokens

There are two ways in which TokenPay tokens (TPAY) can be spent:

1. TPAY can be sent as TPAY.

* When sent as TokenPay tokens, new tokens are minted for the recipient to the value of the input TokenPay minus the transaction fee.*

2. TPAY can be redeemed as TPAY.

* When redeemed as TPAY, new TPAY is created to the value of the input TokenPay minus the transaction fee.*

In both cases the input tokens become unspendable. The transaction fee for spending TokenPay tokens is 100x greater than the fee for standard transactions. This is to cover the cost of the extra activity required by the network to transmit, verify and store shadow transactions, which are larger and require more processing than standard transactions.

In order to spend TokenPay, we use ring signatures to sign the transaction. Our scheme consists of three functions, ```generateRingSignature```, ```generateKeyImage```, ```verifyRingSignature```.

For efficiency’s sake, when spending TokenPay, we get a list of all anonymous outputs in the system, then we remove coins that don't have enough same value outputs in the system, then we choose the smallest coin or least number of smallest coins that can cover the amount + transaction fee.

Each TokenPay Token consist of a unique private key and public key, so what happens when you spend your TokenPay Token? When doing a **normal** transaction (like in Bitcoin), you would prove you received an amount of coins by pointing to the transaction that got you the coins in the first place. That's signed with the private to prove you hold the keys to the address. Now for an **anonymous** transaction that procedure is different: we do not point to previous transactions. Rather we take a pool of coins (public keys of other people their coins) that have the same value as the coin we're trying to spend and then we drop our public key. We then say "we own one of the public keys in this pool of coins", or in cryptographical terms: a ring signature.

## White Paper






# Encrypted Messaging
## Introduction

Digital currencies are often called cryptocurrencies due to the intricate
technical details related to cryptography, but it did not start here. When
looking back at human history, from the cowry shells of the Asian region to the
first coinage in ancient kingdoms, mankind first saw printed money in
medieval times. This breakthrough was followed by modern-day electronic
versions of money. Today, there is an international banking ecosystem, which
consists of banknotes, credit/debit cards, derivatives, stocks, bonds and much
more. It was a combination of human ingenuity and societal commitments that
drove the need to come up with innovative solutions to tackle the most
intricate concept of human interaction handling the exchange of value.
Cryptocurrencies represent the next level in the evolution of money. The
technology behind this new form of money called blockchain. It is entirely
driven by math and is completely decentralized. Most notably, unlike all
previous forms of money, cryptocurrencies are not able to be manipulated. It is
essentially money 2.0.
Blockchain is experiencing a period of exponential growth and adoption, not
unlike the collective transition towards internet use in the 90’s. Established in
2008, Bitcoin is a cryptocurrency based on blockchain. In just a matter of
years, it has become a legitimate and tradable commodity on a global scale. It
has massive liquidity with billions of dollars of Bitcoin traded and used daily.
This exceeds the GDP of many sovereign nations. In fact, the market
capitalization of Bitcoin now exceeds that of Goldman Sachs. There are 16
million Bitcoins in circulation among thousands of holders. Bitcoin is only one
of the more than 850 cryptocurrencies available for people to buy, use and
trade. These other coins are known as altcoins. Many are based on the Bitcoin
platform, others on highly liquid Ethereum and Litecoin. The features of the
coin vary widely from practical to practically useless depending on the
underlying technology. However, there exists a dramatic misalignment in the
metamorphic shift to digital currencies.
The major underlying problem is that traditional financial institutions and the
related governing and operating regulations are not well aligned with
cryptocurrencies. The concept behind public banks was designed and
conceived hundreds of years ago. This is the early stage of a transition
towards the decentralization of the financial world. But there is resistance. The
powerful and entrenched institutions are not keen to transact in
cryptocurrency. And the influence of powerful special interest groups ensures
that traditional banks do everything possible to reject this new form of capital.
However, blockchain technology makes the adoption of cryptocurrencies
possible. It is mathematically fluid and moves much faster than a central bank,
a regulatory body or international fiscal treaties. Currently, there exists an
intermediate “limbo” state whereby many cryptocurrency holders are unable
to benefit from the corresponding economic value. There must be a solution to
this critical problem that is affecting an rapidly increasing amount of people.
© 2017, TokenPay.com or its aliates | TPAY is a utility token used in the TokenPay platform. Purchase does not constitute investment. 14
TokenPay’s platform has been designed to combine the strengths of an
established banking institution with the flexibility and future-forward potential
of cryptocurrency. The network enables the exchange of Bitcoin, Ethereum
and other major cryptocurrencies by bridging the transition gap to fiat. It also
enables unfettered user access to cryptocurrency funds at a merchant point of
sale locations and ATMs worldwide. Users will have the ability to store Bitcoin
and other cryptocurrencies in a secure and insured wallet similar to what
customers at a typical bank provide for fiat accounts. As a result, counterparty
risk is naturally minimized with a licensed and bonded bank. The TPAY token
sale funds are intended to be used to complete a banking acquisition. This
bank will operate in a manner that will cater to and understand the unique
needs of global cryptocurrency holders.

## Key Sharing

The Elliptic Curve Diffie-Hellman (ECDH) key exchange method allows a secret key for encryption to be shared between the sender and recipient using the data embedded in the message along with the private keys of ShadowCash addresses held by the sender and recipient.

This allows for distributing messages, of whom nobody knows the recipient of.

In order to send an encrypted message, you must possess the public key of the intended recipient. The public keys embedded in the TokenPay transaction blockchain when any amount is spent. If you are sending to an address that has not spent a transaction in the blockchain, the public key to that address must be provided manually.

TokenPay uses curve secp256k1 for all elliptic curve functions. This is the same curve used by bitcoin along with the vast majority of altcoins. With such widespread use underpinning systems of immense value it is extremely unlikely that curve secp256k1 is not secure.

Messages are signed by the keys they were sent with, this allows you to be confident of the origin of the messages you receive and also allows the public key of the sender to be extracted from the message, providing you all the information needed to send a reply.

## Encryption

**Detailed Procedure**

- Get public key *K* from destination address
- Find in database created from scanning for public keys in the blockchain and user additions.
- Generate 16 random bytes using a secure random number generator. Call them *IV*. Generate a new random EC key pair with private key called *r* and public key called *R*.
- Generate shared secret key *P* using public key *K* and private key *r*.
- Elliptic Curve Diffie-Hellman
- Use the shared secret key *P* and calculate the SHA512 hash *H*.
- ECDH_compute_key of OpenSSL
- Call the first 32 bytes of *H key_e* and the last 32 bytes *key_m*.
- Calculate a 32 byte MAC with HMACSHA256, using *key_m* as salt and (timestamp + destination + cipher text).
- Message authentication code used
- By also checking time-stamp and destination, recipients can be certain that these fields have not been tampered with.
- Generate a compact signature from the message data and sender's address.
- Only if not sending anonymously
- Recipient can verify that the message came from the sender
- Also allows the public key to be reconstructed (useful to reply)
- Include address and compact signature in the payload to be encrypted.
- Compress the plain-text message with lz4 if the message is larger than 128 bytes.
- Encrypt the payload data with AES-256-CBC, using *IV* as initialization vector, *key_e* as encryption key.

Message Propagation
Encrypted Messages are duplicated on every participating node in the TokenPay network – this prevents adversaries form uncovering the recipient of an encrypted message by using network traffic analysis.

The messages are stored on each node for a maximum period of 48 hours, after which the message is deleted. If the recipient is absent from the network for 48 hours or more the possibility exists that they may not receive messages sent to them. It is recommended to connect to the network each day in order to prevent such an occurrence.

Stored messages are grouped by time in divisions of 1 hour. The system operates on the grouped buckets of messages to save bandwidth.

Synchronization of buckets between peer nodes

Elliptic Curve Diffie-Hellman Key Exchange P2P Messaging
All of the messages sent and received are encrypted by the proven
AES-256-CBC algorithm and distributed between nodes in such a way as to
prevent the recipient's messages from being hacked or viewed by anyone that
it was not intended to, even if the hacker can view the entire network and run
nodes of the network.
To reduce the risk and inconvenience of sharing passwords, TokenPay has
implemented the proven and trusted method of Elliptic Curve Die-Hellman
or also known as an ECDH key exchange. This level of encryption is at the
same level as what a government security agency would use to protect top
secret files and documents.
The Elliptic Curve Digital Signature Algorithm or ECDSA is used to provide
confidence that the messages being transmitted arrive at the intended
destination. Messages are distributed over the existing TokenPay peer-to-peer
network, and a copy of each encrypted message is stored on each node for
48 hours. Following this period, the messages are permanently deleted with
no chance of retrieval by any party

Decryption
For each incoming message a node will attempt to decode the message with every owned address contained in the nodes white-list of addresses to receive messages on.

To speed up the process and allow for any payload format to be used, the Message Authentication Code (MAC) is calculated for the generated shared secret key, if it does not match the MAC provided in the message, decryption will fail and the function ends.

Detailed Procedure

Get IV and R from the message block
Get the private key k of the recipient used to decrypt.
Generate shared secret key P using with private key k and public key R.
Elliptic Curve Diffie-Hellman
Use the shared secret key P to generate the SHA512 hash H.
Call the first 32 bytes of H key_e and the last 32 bytes key_m.
Calculate MAC' with HMACSHA256, using key_m as salt and hash of (time-stamp + destination + cipher text).
Compare MAC with MAC'.
Return if not equal, decryption will fail.
Decrypt the encrypted payload with AES-256-CBC, using IV as initialization vector, key_e as decryption key.
Decompress message portion with lz4 if message is larger than 128 bytes.
If address and compact signature were included then verify the message Address and compact signature are not included when message is sent anonymously strip the sender's public key and add it to the public key database.
White Paper
White paper: View on github


Support
For support please visit one of the links below:

Blog: https://medium.com/tokenpay
Email: Team@tokenpay.com
JSON-RPC API Reference
TokenPay has many new components meaning we also added extra API calls on top of the original Bitcoin API.

addmultisigaddress adds a P2SH multisig address to the wallet.<br />
addnode attempts to add or remove a node from the addnode list, or to try a connection to a node once.<br />
backupwallet safely copies wallet.dat to the specified file, which can be a directory or a path with filename.<br />
createmultisig creates a P2SH multi-signature address.<br />
createrawtransaction creates an unsigned serialized transaction that spends a previous output to a new output with a P2PKH or P2SH address. The transaction is not stored in the wallet or transmitted to the network.<br />
decoderawtransaction decodes a serialized transaction hex string into a JSON object describing the transaction.<br />
decodescript decodes a hex-encoded P2SH redeem script.<br />
dumpprivkey returns the wallet-import-format (WIP) private key corresponding to an address. (But does not remove it from the wallet.)<br />
dumpwallet creates or overwrites a file with all wallet keys in a human-readable format.<br />
encryptwallet encrypts the wallet with a passphrase. This is only to enable encryption for the first time. After encryption is enabled, you will need to enter the passphrase to use private keys.<br />
estimatefee estimates the transaction fee per kilobyte that needs to be paid for a transaction to be included within a certain number of blocks.<br />
estimatepriority estimates the priority that a transaction needs in order to be included within a certain number of blocks as a free high-priority transaction.<br />
generate nearly instantly generates blocks (in regtest mode only)<br />
getaccount returns the name of the account associated with the given address.<br />
getaccountaddress returns the current Bitcoin address for receiving payments to this account. If the account doesn't exist, it creates both the account and a new address for receiving payment. Once a payment has been received to an address, future calls to this RPC for the same account will return a different address.<br />
getaddednodeinfo returns information about the given added node, or all added nodes (except onetry nodes). Only nodes which have been manually added using the addnode RPC will have their information displayed.<br />
getaddressesbyaccount returns a list of every address assigned to a particular account.<br />
getbalance gets the balance in decimal bitcoins across all accounts or for a particular account.<br />
getbestblockhash returns the header hash of the most recent block on the best block chain.<br />
getblock gets a block with a particular header hash from the local block database either as a JSON object or as a serialized block.<br />
getblockchaininfo provides information about the current state of the block chain.<br />
getblockcount returns the number of blocks in the local best block chain.<br />
getblockhash returns the header hash of a block at the given height in the local best block chain.<br />
getblocktemplate gets a block template or proposal for use with mining software.<br />
getchaintips returns information about the highest-height block (tip) of each local block chain.<br />
getconnectioncount returns the number of connections to other nodes.<br />
getdifficulty returns the proof-of-work difficulty as a multiple of the minimum difficulty.<br />
getgenerate returns true if the node is set to generate blocks using its CPU.<br />
getmempoolinfo returns information about the node's current transaction memory pool.<br />
getmininginfo returns various mining-related information.<br />
getnettotals returns information about network traffic, including bytes in, bytes out, and the current time.<br />
getnetworkhashps returns the estimated current or historical network hashes per second based on the last 'n' blocks.<br />
getnetworkinfo returns information about the node's connection to the network.<br />
getnewaddress returns a new TokenPay address for receiving payments. If an account is specified, payments received with the address will be credited to that account.<br />
getpeerinfo returns data about each connected network node.<br />
getrawchangeaddress returns a new TokenPay address for receiving change. This is for use with raw transactions, not normal use.<br />
getrawmempool returns all transaction identifiers (TXIDs) in the memory pool as a JSON array, or detailed information about each transaction in the memory pool as a JSON object.<br />
getrawtransaction gets a hex-encoded serialized transaction or a JSON object describing the transaction.<br />
getreceivedbyaccount returns the total amount received by addresses in a particular account from transactions with the specified number of confirmations.<br />
getreceivedbyaddress returns the total amount received by the specified address in transactions with the specified number of confirmations.<br />
gettransaction gets detailed information about an in-wallet transaction.<br />
gettxout returns details about a transaction output. Only unspent transaction outputs (UTXOs) are guaranteed to be available.<br />
gettxoutsetinfo returns statistics about the confirmed unspent transaction output (UTXO) set.<br />
getunconfirmedbalance returns the wallet's total unconfirmed balance.<br />
getwalletinfo provides information about the wallet.<br />
```help` lists all available public RPC commands, or gets help for the specified RPC. Commands which are unavailable will not be listed, such as wallet RPCs if wallet support is disabled.<br />
importaddress adds an address or pubkey script to the wallet without the associated private key, allowing you to watch for transactions affecting that address or pubkey script without being able to spend any of its outputs.<br />
importprivkey adds a private key to your wallet. The key should be formatted in the wallet import format created by the dumpprivkey RPC.<br />
importwallet imports private keys from a file in wallet dump file format (see the dumpwallet RPC). These keys will be added to the keys currently in the wallet.<br />
keypoolrefill fills the cache of unused pre-generated keys (the keypool).<br />
listaccounts lists accounts and their balances.<br />
listaddressgroupings lists groups of addresses that may have had their common ownership made public by common use as inputs in the same transaction or from being used as change from a previous transaction.<br />
listlockunspent returns a list of temporarily unspendable (locked) outputs.<br />
listreceivedbyaccount lists the total number of bitcoins received by each account.<br />
listreceivedbyaddress lists the total number of bitcoins received by each address.<br />
listsinceblock gets all transactions affecting the wallet which have occurred since a particular block, plus the header hash of a block at a particular depth.<br />
listtransactions returns the most recent transactions that affect the wallet.<br />
listunspent returns an array of unspent transaction outputs belonging to this wallet.<br />
lockunspent temporarily locks or unlocks specified transaction outputs.<br />
move moves a specified amount from one account in your wallet to another using an off-block-chain transaction.<br />
ping sends a P2P ping message to all connected nodes to measure ping time.<br />
prioritisetransaction adds virtual priority or fee to a transaction, allowing it to be accepted into blocks mined by this node (or miners which use this node) with a lower priority or fee.<br />
sendfrom spends an amount from a local account to a TokenPay address.<br />
sendmany creates and broadcasts a transaction which sends outputs to multiple addresses.<br />
sendrawtransaction validates a transaction and broadcasts it to the peer-to-peer network.<br />
sendtoaddress sends an amount to a given address.<br />
setaccount puts the specified address in the given account.<br />
setgenerate enables or disables hashing to attempt to find the next block.<br />
settxfee sets the transaction fee per kilobyte paid by transactions created by this wallet.<br />
signmessage signs a message with the private key of an address.<br />
signrawtransaction signs a transaction in the serialized transaction format using private keys stored in the wallet or provided in the call.<br />
stop safely shuts down the TokenPay Core server.<br />
submitblock accepts a block, verifies it is a valid addition to the block chain, and broadcasts it to the network.<br />
validateaddress returns information about the given TokenPay address.<br />
verifychain verifies each entry in the local block chain database.<br />
verifymessage verifies a signed message.<br />
walletlock removes the wallet encryption key from memory, locking the wallet. After calling this method, you will need to call walletpassphrase again before being able to call any methods which require the wallet to be unlocked.<br />
walletpassphrase stores the wallet decryption key in memory for the indicated number of seconds. Issuing the walletpassphrase command while the wallet is already unlocked will set a new unlock time that overrides the old one.<br />
walletpassphrasechange changes the wallet passphrase from 'old passphrase' to 'new passphrase'.<br />
TokenPay RPC<br />
anoninfo<br />
anoninfo [recalculate]<br />
anonoutputs<br />
anonoutputs [systemTotals] [show_immature_outputs]<br />
checkwallet<br />
Check wallet for integrity.<br />

clearwallettransactions
Delete all transactions from wallet - reload with reloadanondata Warning: Backup your wallet first!

estimateanonfee
estimateanonfee <amount> <ring_size> [narration]
is a real and is rounded to the nearest 0.000001 Used to estimate the anon fee with a given amount and ring size.

getnewpubkey<br />
getnewpubkey [account]<br />
getnewstealthaddress<br />
getnewstealthaddress [label]<br />
getstakinginfo<br />
getsubsidy<br />
getsubsidy [nTarget]<br />
getwork<br />
getwork [data]<br />
getworkex<br />
getworkex [data, coinbase]<br />
help<br />
help [command]<br />
importstealthaddress<br />
importstealthaddress <scan_secret> <spend_secret> [label]<br />
liststealthaddresses<br />
liststealthaddresses [show_secrets=0]<br />
List owned stealth addresses.<br />

When used with show_secrets=1 it will return a list of all stealth addresses, the labels, the scan secrets and spend secrets.<br />

listtransactions<br /><br />
listtransactions [account] [count=10] [from=0] [show_coinstake=1]<br />
Returns up to [count] most recent transactions skipping the first [from] transactions for account [account]. If you want to process Stealth transactions (TPAY) then you want to use this function.<br />

There a bit of a trick necessary to get the stealth transactions, easier explained in an example: Stealth address = "smYmoN9xyenTSow9RP4ecf172sdKTeN9k4ZVCiUhFY6MTQRqSS2LRSZSZECwnZSb1a7EaCNc4aPrmrkexBXEs4qeJTZ6m9NjJBgnQE" => Account name = "ao smYmoN9xyenTSow9..."<br />

When stealth addresses are generated their account name is "ao first_16_chars...", the 3 dots at the end are important!<br />

makekeypair<br />
makekeypair [prefix]<br />
nextorphan<br />
nextorphan [connecthash]<br />
reloadanondata<br />
Removes all wallet transactions, anon cache, and rebuilds everything from zero.<br />

repairwallet<br />
Repair wallet if checkwallet reports any problem<br />

resendtx<br />
reservebalance<br />
reservebalance [<reserve> [amount]]<br />
rewindchain<br />
rewindchain <number><br />
scanforalltxns<br />
Scans for all transactions and overwrites prior history and does update.<br />

scanforalltxns [fromHeight]<br />
scanforstealthtxns<br />
Scans for all Stealth transactions and overwrites prior history and does update.<br />

scanforstealthtxns [fromHeight]<br />
sendalert<br />
sendalert <message> <privatekey> <minver> <maxver> <priority> <id> [cancelupto]<br />
sendanontoanon<br />
sendanontoanon <stealth_address> <amount> <ring_size> [narration] [comment] [comment-to]<br />
sendanontoTPAY<br />
sendanontoTPAY <stealth_address> <amount> <ring_size> [narration] [comment] [comment-to]<br />
sendTPAYtoanon<br />
sendTPAYtoanon <stealth_address> <amount> [narration] [comment] [comment-to]<br />
sendtostealthaddress<br />
sendtostealthaddress <stealth_address> <amount> [comment] [comment-to] [narration]<br />
setbestblockbyheight<br />
setbestblockbyheight <height><br />
settxfee<br />
settxfee <amount><br />
stop<br />
Stop the tokenpay server<br />

thinscanmerkleblocks<br />
thinscanmerkleblocks <height><br />
txnreport<br />
txnreport [collate_amounts] [show_key_images]<br />
thinforcestate<br />
thinforcestate <state><br />
thinscanmerkleblocks<br />
thinscanmerkleblocks <height><br />
txnreport<br />
txnreport [collate_amounts] [show_key_images]<br />
validatepubkey<br />
validatepubkey <tokenpaypubkey><br />
SMSG API<br />
smsgaddkey<br />
smsgaddkey

smsgaddkey <address> <pubkey><br />
smsgbuckets [stats|dump]<br />
smsgbuckets [stats|dump]<br />
Display some statistics.<br />

smsgdisable<br />
Disable secure messaging<br />

smsgenable<br />
Enable secure messaging<br />

smsggetpubkey<br />
smsggetpubkey <address><br />
Returns the public key for a given address.<br />

Example:<br />
smsggetpubkey tFyq452LPtDotWat8PFwEV5oPoWDqagLNv<br />
Output:<br />
{<br />
"result" : "Success.",<br />
"address in wallet" : "tFyq452LPtDotWat8PFwEV5oPoWDqagLNv",<br />
"compressed public key" : "26S8iEiv2754RskjkWqRZkbZ22iNRYPgK7sUPyRPueXni"<br />
}<br />
smsginbox<br />
smsginbox [all|unread|clear]<br />
Decrypt and display all received messages. "all" will show all messages, "unread" will only show the unread messages.<br />

Warning: clear will delete all messages.<br />
Example:<br />
smsginbox all<br />

Output:<br />
{<br />
"message" : {<br />
"received" : "2015-09-13 16:19:53 Romance",<br />
"sent" : "2015-09-13 16:19:51 Romance",<br />
"from" : "anon",<br />
"to" : "tFyq452LPtDotWat8PFwEV5oPoWDqagLNv",<br />
"text" : "TokenPay is awesome"<br />
},<br />
"message" : {<br />
"received" : "2015-09-13 16:18:36 Romance",<br />
"sent" : "2015-09-13 16:18:35 Romance ",<br />
"from" : "anon",<br />
"to" : "tFyq452LPtDotWat8PFwEV5oPoWDqagLNv",<br />
"text" : "This secure messagings is brilliant!"<br />
},<br />
"result" : "2 messages shown."<br />
}<br />
smsglocalkeys<br />
List and manage keys.<br />

smsglocalkeys [whitelist|all|wallet|recv <+/-> <address>|anon <+/-> <address>]<br />
smsgoptions<br />
smsgoptions [list|set <optname> <value>]<br />
List and manage the secure message options.<br />

Example 1:<br />
smsgoptions list<br />

Output:<br />
{<br />
"option" : "newAddressRecv = true",<br />
"option" : "newAddressAnon = true",<br />
"result" : "Success."<br />

Example 2:<br />
smsgoptions set newAddressRecv false<br />

Output:<br />
{<br />
"option" : "newAddressRecv = false",<br />
"option" : "newAddressAnon = true",<br />
"result" : "Success."<br />
}<br />
smsgoutbox<br />
smsgoutbox [all|clear]<br />
Decrypt and display all sent messages.<br />

Warning: clear will delete all sent messages.<br />
Will also show all messages sent with smsganonsend.<br />

Example:<br />

smsgoutbox<br />

Output:<br />
{<br />
"message" : {<br />
"sent" : "2015-09-13 16:19:51 Romance",<br />
"from" : "anon",<br />
"to" : "tFyq452LPtDotWat8PFwEV5oPoWDqagLNv",<br />
"text" : "TokenPay is awesome"<br />
},<br />
"message" : {<br />
"sent" : "2015-09-13 16:18:35 Romance",<br />
"from" : "anon",<br />
"to" : "tFyq452LPtDotWat8PFwEV5oPoWDqagLNv",<br />
"text" : "This secure messaging is brilliant!"<br />
},<br />
"result" : "2 sent messages shown."<br />
}<br />
smsgscanbuckets<br />
Force rescan of all messages in the bucket store.<br />

smsgscanchain<br />
Look for public keys in the block chain.<br />
<br />
smsgsend<br />
smsgsend <addrFrom> <addrTo> <message><br />
smsgsendanon<br />
smsgsendanon <addrTo> <message><br />
Send and anonymous message to an address.<br />

smsgsendanon tFyq452LPtDotWat8PFwEV5oPoWDqagLNv "This secure messagings is brilliant!"<br />

Output:<br />
{<br />
"result" : "Sent."<br />
}<br />

Code<br />
TokenPay is controlled by all TokenPay users around the world. If you are a developer, you can use your super-powers to do good and contribute. The TokenPay project is hosted on GitHub. This is where developers work hard on the next version(s) of the software. To get involved with developing TokenPay, check out our detailed contributing guidelines. We credit all contributors to the TokenPay project in every major and minor release.<br />

We hold public development meetings and chat in our Slack team. We also maintain a public roadmap and dev blog to give you an idea of what's being worked on right now, and what's coming next. Are you someone who might be interested? Do not hesitate and contact us directly.<br />




If you think you've found a bug or a problem with TokenPay, please let us know! First, search our issue tracker to search to see if someone has already reported the problem. If they haven't, click here to open a new issue, and fill out the template with as much information as possible. The more you can tell us about the problem and how it occurred, the more likely we are to fix it. Please check out our bug and bounty program for our guidelines and more details.<br />

Please do not report security vulnerabilities publicly. The details for responsible disclosure of security issues can be found in our bug and bounty program.<br />

Bugs & Bounty program<br />



TokenPay has a series of bug bounties. Similar to the bounties offered by Mozilla and Google, TokenPay bug bounties provide an opportunity for people who find bugs to be compensated. Unlike those programs, however, TokenPay’s bounties are not limited to security vulnerabilities.<br />

Depending on the type of bug and when it is reported, different bounties will be awarded. Bounties are paid out in TPAY, at the 3-day average of each to a fixed US Dollar value.<br />

Things that do not qualify under the bug bounty<br />
Bugs found on third-party/community sites, software or services, which is not due to an improper configuration issue specific to us. Please submit any potential issues to the maintainers of that site or providers of that service.<br />
Vulnerabilities which are too broad or not documented properly (i.e. do not include a specific example relevant to a - TokenPay-controlled site or application).<br />
Bugs or issues with a third-party site, software, or service that we use, which is not due to an improper configuration issue specific to us. Please submit any potential issues to the maintainers of that site or providers of that service.<br />
Bugs and errors found in software/code that is still undergoing alpha or beta testing.<br />
Usability issues<br />
Anything requiring social engineering<br />
DOS/DDOS attacks<br />
Missing HSTS (HttpOnly flags), Secure flag, Browser Cache vulnerabilities<br />
CSRF that doesn’t affect the victim<br />
Referrer leakage to pages an attacker cannot control.<br />
The presence of unnecessary files, e.g. for backups, when these files do not expose any sensitive information.<br />
Anything that is the result of an automated Nessus/PCI scans (too general)<br />
DNS issues (e.g. lack of an SPF record)<br />
SSL certificate issues<br />
Bugs that have received mainstream tech media or community attention before the date of your disclosure.<br />
Bug Bounties and Rewards<br />
$3000 Deanonymize TokenPay (proof that a protocol is not anonymous)<br />
$1500 A flaw in the protocol that allows for theft or loss of funds<br />
$1000 A bug in the reference client that leads to consensus issues<br />
$8000 A bug which causes data corruption or loss<br />
$200 A bug which causes the application to crash<br />
$100 Other non-harmless bugs<br />
$20 ‘Harmless’ bugs, e.g. cosmetic errors<br />
How to report a bug<br />
Security-related issues<br />
Contact the developers privately by sending an e-mail to Team@tokenpay.com with the details of the issue. Do not post the issue on github or anywhere else until the issue has been resolved.<br />

Code issues<br />
We would strongly prefer if you create a pull-request on Github in the proper repository with the necessary fix (along with your TPAY address to claim the bounty). For more information, see this link.<br />
